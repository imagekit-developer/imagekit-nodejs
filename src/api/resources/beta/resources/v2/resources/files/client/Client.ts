/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../../../environments.js";
import * as core from "../../../../../../../../core/index.js";
import * as ImageKit from "../../../../../../../index.js";
import * as fs from "fs";
import { toJson } from "../../../../../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../../../core/headers.js";
import * as errors from "../../../../../../../../errors/index.js";

export declare namespace Files {
    export interface Options {
        environment?: core.Supplier<environments.ImageKitEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        username: core.Supplier<string>;
        password: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Files {
    protected readonly _options: Files.Options;

    constructor(_options: Files.Options) {
        this._options = _options;
    }

    /**
     * The V2 API enhances security by verifying the entire payload using JWT. This API is in beta.
     *
     * ImageKit.io allows you to upload files directly from both the server and client sides. For server-side uploads, private API key authentication is used. For client-side uploads, generate a one-time `token` from your secure backend using private API. [Learn more](/docs/api-reference/upload-file/upload-file-v2#how-to-implement-secure-client-side-file-upload) about how to implement secure client-side file upload.
     *
     * **File size limit** \
     * On the free plan, the maximum upload file sizes are 20MB for images, audio, and raw files, and 100MB for videos. On the paid plan, these limits increase to 40MB for images, audio, and raw files, and 2GB for videos. These limits can be further increased with higher-tier plans.
     *
     * **Version limit** \
     * A file can have a maximum of 100 versions.
     *
     * **Demo applications**
     *
     * - A full-fledged [upload widget using Uppy](https://github.com/imagekit-samples/uppy-uploader), supporting file selections from local storage, URL, Dropbox, Google Drive, Instagram, and more.
     * - [Quick start guides](/docs/quick-start-guides) for various frameworks and technologies.
     *
     * @param {ImageKit.beta.v2.FileUploadV2} request
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.beta.v2.files.upload({
     *         file: fs.createReadStream("/path/to/your/file"),
     *         fileName: "fileName"
     *     })
     */
    public upload(
        request: ImageKit.beta.v2.FileUploadV2,
        requestOptions?: Files.RequestOptions,
    ): core.HttpResponsePromise<ImageKit.Upload> {
        return core.HttpResponsePromise.fromPromise(this.__upload(request, requestOptions));
    }

    private async __upload(
        request: ImageKit.beta.v2.FileUploadV2,
        requestOptions?: Files.RequestOptions,
    ): Promise<core.WithRawResponse<ImageKit.Upload>> {
        const _request = await core.newFormData();
        await _request.appendFile("file", request.file);
        _request.append("fileName", request.fileName);
        if (request.token != null) {
            _request.append("token", request.token);
        }

        if (request.useUniqueFileName != null) {
            _request.append("useUniqueFileName", request.useUniqueFileName.toString());
        }

        if (request.tags != null) {
            for (const _item of request.tags) {
                _request.append("tags", _item);
            }
        }

        if (request.folder != null) {
            _request.append("folder", request.folder);
        }

        if (request.isPrivateFile != null) {
            _request.append("isPrivateFile", request.isPrivateFile.toString());
        }

        if (request.isPublished != null) {
            _request.append("isPublished", request.isPublished.toString());
        }

        if (request.customCoordinates != null) {
            _request.append("customCoordinates", request.customCoordinates);
        }

        if (request.responseFields != null) {
            for (const _item of request.responseFields) {
                _request.append("responseFields", _item);
            }
        }

        if (request.extensions != null) {
            for (const _item of request.extensions) {
                _request.append("extensions", typeof _item === "string" ? _item : toJson(_item));
            }
        }

        if (request.webhookUrl != null) {
            _request.append("webhookUrl", request.webhookUrl);
        }

        if (request.overwriteFile != null) {
            _request.append("overwriteFile", request.overwriteFile.toString());
        }

        if (request.overwriteAITags != null) {
            _request.append("overwriteAITags", request.overwriteAITags.toString());
        }

        if (request.overwriteTags != null) {
            _request.append("overwriteTags", request.overwriteTags.toString());
        }

        if (request.overwriteCustomMetadata != null) {
            _request.append("overwriteCustomMetadata", request.overwriteCustomMetadata.toString());
        }

        if (request.customMetadata != null) {
            _request.append("customMetadata", toJson(request.customMetadata));
        }

        if (request.transformation != null) {
            _request.append("transformation", toJson(request.transformation));
        }

        if (request.checks != null) {
            _request.append("checks", request.checks);
        }

        if (request.description != null) {
            _request.append("description", request.description);
        }

        const _maybeEncodedRequest = await _request.getRequest();
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                "api/v2/files/upload",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as ImageKit.Upload, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling POST /api/v2/files/upload.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        return core.BasicAuth.toAuthorizationHeader({
            username: await core.Supplier.get(this._options.username),
            password: await core.Supplier.get(this._options.password),
        });
    }
}
