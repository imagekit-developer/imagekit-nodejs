/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as ImageKit from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace CustomMetadataFields {
    export interface Options {
        environment?: core.Supplier<environments.ImageKitEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        username: core.Supplier<string>;
        password: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class CustomMetadataFields {
    protected readonly _options: CustomMetadataFields.Options;

    constructor(_options: CustomMetadataFields.Options) {
        this._options = _options;
    }

    /**
     * This API returns the array of created custom metadata field objects. By default the API returns only non deleted field objects, but you can include deleted fields in the API response.
     *
     * @param {ImageKit.CustomMetadataFieldsListRequest} request
     * @param {CustomMetadataFields.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.customMetadataFields.list()
     */
    public list(
        request: ImageKit.CustomMetadataFieldsListRequest = {},
        requestOptions?: CustomMetadataFields.RequestOptions,
    ): core.HttpResponsePromise<ImageKit.CustomMetadataField[]> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: ImageKit.CustomMetadataFieldsListRequest = {},
        requestOptions?: CustomMetadataFields.RequestOptions,
    ): Promise<core.WithRawResponse<ImageKit.CustomMetadataField[]>> {
        const { includeDeleted } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (includeDeleted != null) {
            _queryParams["includeDeleted"] = includeDeleted.toString();
        }

        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                "v1/customMetadataFields",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as ImageKit.CustomMetadataField[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling GET /v1/customMetadataFields.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This API creates a new custom metadata field. Once a custom metadata field is created either through this API or using the dashboard UI, its value can be set on the assets. The value of a field for an asset can be set using the media library UI or programmatically through upload or update assets API.
     *
     * @param {ImageKit.CustomMetadataFieldsCreateRequest} request
     * @param {CustomMetadataFields.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.customMetadataFields.create({
     *         name: "price",
     *         label: "price",
     *         schema: {
     *             type: "Number",
     *             minValue: 1000,
     *             maxValue: 3000
     *         }
     *     })
     */
    public create(
        request: ImageKit.CustomMetadataFieldsCreateRequest,
        requestOptions?: CustomMetadataFields.RequestOptions,
    ): core.HttpResponsePromise<ImageKit.CustomMetadataField> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: ImageKit.CustomMetadataFieldsCreateRequest,
        requestOptions?: CustomMetadataFields.RequestOptions,
    ): Promise<core.WithRawResponse<ImageKit.CustomMetadataField>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                "v1/customMetadataFields",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as ImageKit.CustomMetadataField, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling POST /v1/customMetadataFields.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This API deletes a custom metadata field. Even after deleting a custom metadata field, you cannot create any new custom metadata field with the same name.
     *
     * @param {string} id - Should be a valid custom metadata field id.
     * @param {CustomMetadataFields.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.NotFoundError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.customMetadataFields.delete("id")
     */
    public delete(
        id: string,
        requestOptions?: CustomMetadataFields.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
    }

    private async __delete(
        id: string,
        requestOptions?: CustomMetadataFields.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                `v1/customMetadataFields/${encodeURIComponent(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new ImageKit.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError(
                    "Timeout exceeded when calling DELETE /v1/customMetadataFields/{id}.",
                );
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This API updates the label or schema of an existing custom metadata field.
     *
     * @param {string} id - Should be a valid custom metadata field id.
     * @param {ImageKit.CustomMetadataFieldsUpdateRequest} request
     * @param {CustomMetadataFields.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.NotFoundError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.customMetadataFields.update("id", {
     *         label: "price",
     *         schema: {
     *             minValue: 1000,
     *             maxValue: 3000
     *         }
     *     })
     */
    public update(
        id: string,
        request: ImageKit.CustomMetadataFieldsUpdateRequest = {},
        requestOptions?: CustomMetadataFields.RequestOptions,
    ): core.HttpResponsePromise<ImageKit.CustomMetadataField> {
        return core.HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
    }

    private async __update(
        id: string,
        request: ImageKit.CustomMetadataFieldsUpdateRequest = {},
        requestOptions?: CustomMetadataFields.RequestOptions,
    ): Promise<core.WithRawResponse<ImageKit.CustomMetadataField>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                `v1/customMetadataFields/${encodeURIComponent(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as ImageKit.CustomMetadataField, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new ImageKit.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError(
                    "Timeout exceeded when calling PATCH /v1/customMetadataFields/{id}.",
                );
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        return core.BasicAuth.toAuthorizationHeader({
            username: await core.Supplier.get(this._options.username),
            password: await core.Supplier.get(this._options.password),
        });
    }
}
