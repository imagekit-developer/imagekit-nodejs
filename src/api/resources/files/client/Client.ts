/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as ImageKit from "../../../index.js";
import * as fs from "fs";
import { toJson } from "../../../../core/json.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";
import { Bulk } from "../resources/bulk/client/Client.js";
import { Versions } from "../resources/versions/client/Client.js";
import { Metadata } from "../resources/metadata/client/Client.js";

export declare namespace Files {
    export interface Options {
        environment?: core.Supplier<environments.ImageKitEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        username: core.Supplier<string>;
        password: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Files {
    protected readonly _options: Files.Options;
    protected _bulk: Bulk | undefined;
    protected _versions: Versions | undefined;
    protected _metadata: Metadata | undefined;

    constructor(_options: Files.Options) {
        this._options = _options;
    }

    public get bulk(): Bulk {
        return (this._bulk ??= new Bulk(this._options));
    }

    public get versions(): Versions {
        return (this._versions ??= new Versions(this._options));
    }

    public get metadata(): Metadata {
        return (this._metadata ??= new Metadata(this._options));
    }

    /**
     * ImageKit.io allows you to upload files directly from both the server and client sides. For server-side uploads, private API key authentication is used. For client-side uploads, generate a one-time `token`, `signature`, and `expiration` from your secure backend using private API. [Learn more](/docs/api-reference/upload-file/upload-file#how-to-implement-client-side-file-upload) about how to implement client-side file upload.
     *
     * The [V2 API](/docs/api-reference/upload-file/upload-file-v2) enhances security by verifying the entire payload using JWT.
     *
     * **File size limit** \
     * On the free plan, the maximum upload file sizes are 20MB for images, audio, and raw files and 100MB for videos. On the paid plan, these limits increase to 40MB for images, audio, and raw files and 2GB for videos. These limits can be further increased with higher-tier plans.
     *
     * **Version limit** \
     * A file can have a maximum of 100 versions.
     *
     * **Demo applications**
     *
     * - A full-fledged [upload widget using Uppy](https://github.com/imagekit-samples/uppy-uploader), supporting file selections from local storage, URL, Dropbox, Google Drive, Instagram, and more.
     * - [Quick start guides](/docs/quick-start-guides) for various frameworks and technologies.
     *
     * @param {ImageKit.FileUploadV1} request
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.files.upload({
     *         file: fs.createReadStream("/path/to/your/file"),
     *         fileName: "fileName"
     *     })
     */
    public upload(
        request: ImageKit.FileUploadV1,
        requestOptions?: Files.RequestOptions,
    ): core.HttpResponsePromise<ImageKit.Upload> {
        return core.HttpResponsePromise.fromPromise(this.__upload(request, requestOptions));
    }

    private async __upload(
        request: ImageKit.FileUploadV1,
        requestOptions?: Files.RequestOptions,
    ): Promise<core.WithRawResponse<ImageKit.Upload>> {
        const _request = await core.newFormData();
        await _request.appendFile("file", request.file);
        _request.append("fileName", request.fileName);
        if (request.publicKey != null) {
            _request.append("publicKey", request.publicKey);
        }

        if (request.signature != null) {
            _request.append("signature", request.signature);
        }

        if (request.expire != null) {
            _request.append("expire", request.expire.toString());
        }

        if (request.token != null) {
            _request.append("token", request.token);
        }

        if (request.useUniqueFileName != null) {
            _request.append("useUniqueFileName", request.useUniqueFileName.toString());
        }

        if (request.tags != null) {
            for (const _item of request.tags) {
                _request.append("tags", _item);
            }
        }

        if (request.folder != null) {
            _request.append("folder", request.folder);
        }

        if (request.isPrivateFile != null) {
            _request.append("isPrivateFile", request.isPrivateFile.toString());
        }

        if (request.isPublished != null) {
            _request.append("isPublished", request.isPublished.toString());
        }

        if (request.customCoordinates != null) {
            _request.append("customCoordinates", request.customCoordinates);
        }

        if (request.responseFields != null) {
            for (const _item of request.responseFields) {
                _request.append("responseFields", _item);
            }
        }

        if (request.extensions != null) {
            for (const _item of request.extensions) {
                _request.append("extensions", typeof _item === "string" ? _item : toJson(_item));
            }
        }

        if (request.webhookUrl != null) {
            _request.append("webhookUrl", request.webhookUrl);
        }

        if (request.overwriteFile != null) {
            _request.append("overwriteFile", request.overwriteFile.toString());
        }

        if (request.overwriteAITags != null) {
            _request.append("overwriteAITags", request.overwriteAITags.toString());
        }

        if (request.overwriteTags != null) {
            _request.append("overwriteTags", request.overwriteTags.toString());
        }

        if (request.overwriteCustomMetadata != null) {
            _request.append("overwriteCustomMetadata", request.overwriteCustomMetadata.toString());
        }

        if (request.customMetadata != null) {
            _request.append("customMetadata", toJson(request.customMetadata));
        }

        if (request.transformation != null) {
            _request.append("transformation", toJson(request.transformation));
        }

        if (request.checks != null) {
            _request.append("checks", request.checks);
        }

        if (request.description != null) {
            _request.append("description", request.description);
        }

        const _maybeEncodedRequest = await _request.getRequest();
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                "api/v1/files/upload",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as ImageKit.Upload, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling POST /api/v1/files/upload.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This API returns an object with details or attributes about the current version of the file.
     *
     * @param {string} fileId - The unique `fileId` of the uploaded file. `fileId` is returned in the list and search assets API and upload API.
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.NotFoundError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.files.get("fileId")
     */
    public get(fileId: string, requestOptions?: Files.RequestOptions): core.HttpResponsePromise<ImageKit.FileDetails> {
        return core.HttpResponsePromise.fromPromise(this.__get(fileId, requestOptions));
    }

    private async __get(
        fileId: string,
        requestOptions?: Files.RequestOptions,
    ): Promise<core.WithRawResponse<ImageKit.FileDetails>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                `v1/files/${encodeURIComponent(fileId)}/details`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as ImageKit.FileDetails, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new ImageKit.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling GET /v1/files/{fileId}/details.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This API updates the details or attributes of the current version of the file. You can update `tags`, `customCoordinates`, `customMetadata`, publication status, remove existing `AITags` and apply extensions using this API.
     *
     * @param {string} fileId - The unique `fileId` of the uploaded file. `fileId` is returned in list and search assets API and upload API.
     * @param {ImageKit.FilesUpdateRequest} request
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.NotFoundError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.files.update("fileId", {
     *         removeAITags: ["car", "vehicle", "motorsports"],
     *         webhookUrl: "https://webhook.site/0d6b6c7a-8e5a-4b3a-8b7c-0d6b6c7a8e5a",
     *         extensions: [{
     *                 name: "remove-bg",
     *                 options: {
     *                     add_shadow: true
     *                 }
     *             }, {
     *                 name: "google-auto-tagging",
     *                 minConfidence: 80,
     *                 maxTags: 10
     *             }, {
     *                 name: "aws-auto-tagging",
     *                 minConfidence: 80,
     *                 maxTags: 10
     *             }, {
     *                 name: "ai-auto-description"
     *             }],
     *         tags: ["tag1", "tag2"],
     *         customCoordinates: "10,10,100,100",
     *         customMetadata: {
     *             "brand": "Nike",
     *             "color": "red"
     *         }
     *     })
     */
    public update(
        fileId: string,
        request: ImageKit.FilesUpdateRequest,
        requestOptions?: Files.RequestOptions,
    ): core.HttpResponsePromise<ImageKit.FilesUpdateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__update(fileId, request, requestOptions));
    }

    private async __update(
        fileId: string,
        request: ImageKit.FilesUpdateRequest,
        requestOptions?: Files.RequestOptions,
    ): Promise<core.WithRawResponse<ImageKit.FilesUpdateResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                `v1/files/${encodeURIComponent(fileId)}/details`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as ImageKit.FilesUpdateResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new ImageKit.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError(
                    "Timeout exceeded when calling PATCH /v1/files/{fileId}/details.",
                );
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This API deletes the file and all its file versions permanently.
     *
     * Note: If a file or specific transformation has been requested in the past, then the response is cached. Deleting a file does not purge the cache. You can purge the cache using purge cache API.
     *
     * @param {string} fileId - The unique `fileId` of the uploaded file. `fileId` is returned in list and search assets API and upload API.
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.NotFoundError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.files.delete("fileId")
     */
    public delete(fileId: string, requestOptions?: Files.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__delete(fileId, requestOptions));
    }

    private async __delete(fileId: string, requestOptions?: Files.RequestOptions): Promise<core.WithRawResponse<void>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                `v1/files/${encodeURIComponent(fileId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new ImageKit.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling DELETE /v1/files/{fileId}.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This will copy a file from one folder to another.
     *
     * Note: If any file at the destination has the same name as the source file, then the source file and its versions (if `includeFileVersions` is set to true) will be appended to the destination file version history.
     *
     * @param {ImageKit.FilesCopyRequest} request
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.NotFoundError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.files.copy({
     *         sourceFilePath: "/path/to/file.jpg",
     *         destinationPath: "/folder/to/copy/into/"
     *     })
     */
    public copy(
        request: ImageKit.FilesCopyRequest,
        requestOptions?: Files.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(this.__copy(request, requestOptions));
    }

    private async __copy(
        request: ImageKit.FilesCopyRequest,
        requestOptions?: Files.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                "v1/files/copy",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new ImageKit.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling POST /v1/files/copy.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This will move a file and all its versions from one folder to another.
     *
     * Note: If any file at the destination has the same name as the source file, then the source file and its versions will be appended to the destination file.
     *
     * @param {ImageKit.FilesMoveRequest} request
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.NotFoundError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.files.move({
     *         sourceFilePath: "/path/to/file.jpg",
     *         destinationPath: "/folder/to/move/into/"
     *     })
     */
    public move(
        request: ImageKit.FilesMoveRequest,
        requestOptions?: Files.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(this.__move(request, requestOptions));
    }

    private async __move(
        request: ImageKit.FilesMoveRequest,
        requestOptions?: Files.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                "v1/files/move",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new ImageKit.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling POST /v1/files/move.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * You can rename an already existing file in the media library using rename file API. This operation would rename all file versions of the file.
     *
     * Note: The old URLs will stop working. The file/file version URLs cached on CDN will continue to work unless a purge is requested.
     *
     * @param {ImageKit.FilesRenameRequest} request
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link ImageKit.BadRequestError}
     * @throws {@link ImageKit.UnauthorizedError}
     * @throws {@link ImageKit.ForbiddenError}
     * @throws {@link ImageKit.NotFoundError}
     * @throws {@link ImageKit.ConflictError}
     * @throws {@link ImageKit.TooManyRequestsError}
     *
     * @example
     *     await client.files.rename({
     *         filePath: "/path/to/file.jpg",
     *         newFileName: "newFileName.jpg"
     *     })
     */
    public rename(
        request: ImageKit.FilesRenameRequest,
        requestOptions?: Files.RequestOptions,
    ): core.HttpResponsePromise<ImageKit.FilesRenameResponse> {
        return core.HttpResponsePromise.fromPromise(this.__rename(request, requestOptions));
    }

    private async __rename(
        request: ImageKit.FilesRenameRequest,
        requestOptions?: Files.RequestOptions,
    ): Promise<core.WithRawResponse<ImageKit.FilesRenameResponse>> {
        var _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ImageKitEnvironment.Default,
                "v1/files/rename",
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as ImageKit.FilesRenameResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new ImageKit.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new ImageKit.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new ImageKit.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new ImageKit.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new ImageKit.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 429:
                    throw new ImageKit.TooManyRequestsError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.ImageKitError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ImageKitError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ImageKitTimeoutError("Timeout exceeded when calling PUT /v1/files/rename.");
            case "unknown":
                throw new errors.ImageKitError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        return core.BasicAuth.toAuthorizationHeader({
            username: await core.Supplier.get(this._options.username),
            password: await core.Supplier.get(this._options.password),
        });
    }
}
